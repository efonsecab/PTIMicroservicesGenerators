using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading;

namespace PTI.Microservices.Generators
{
    public class GeneratorAdditionalText : AdditionalText
    {
        public override string Path { get; }
        public GeneratorAdditionalText(string path)
        {
            this.Path = path;
        }

        public override SourceText GetText(CancellationToken cancellationToken = default)
        {
            var text = System.IO.File.ReadAllText(this.Path);
            return SourceText.From(text);
        }
    }

    [Generator]
    public class OpenApiClientServicesGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            HttpClient httpClient = new HttpClient();
            System.Diagnostics.Debug.WriteLine("YOLA YOLA");
            foreach (var singleAdditionalFile in context.AdditionalFiles)
            {
                if (singleAdditionalFile is AdditionalText)
                {
                    var sourceText = singleAdditionalFile.GetText(context.CancellationToken);
                    foreach (var singleLine in sourceText.Lines)
                    {
                        var requestUrl = singleLine.ToString();
                        var json = httpClient.GetStringAsync(requestUrl).Result;
                        GenerateClassFromOpenApiJsonString(json, context);
                    }
                }
            }
            //HttpClient httpClient = new HttpClient();
            //Debug.WriteLine("Autogenerated PTI Service");
            //if (context.SyntaxReceiver is OpenApiClientServicesGeneratorSyntaxReceiver)
            //{
            //    var receiver = context.SyntaxReceiver as OpenApiClientServicesGeneratorSyntaxReceiver;
            //    foreach (var singleRequestedOpenApiDocUrl in receiver.RequestedOpenApiDocsUrls)
            //    {
            //        Uri requestUrl = new Uri(singleRequestedOpenApiDocUrl);
            //        var json = httpClient.GetStringAsync(requestUrl).Result;
            //        GenerateClassFromOpenApiJsonString(json, context);
            //    }
            //}
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new OpenApiClientServicesGeneratorSyntaxReceiver());
        }

        private void GenerateClassFromOpenApiJsonString(string json, GeneratorExecutionContext context)
        {
            Microsoft.OpenApi.Readers.OpenApiStringReader openApiStringReader = new Microsoft.OpenApi.Readers.OpenApiStringReader();
            var openApiDocument = openApiStringReader.Read(json, out var diagnostics);
            StringBuilder classDocument = new StringBuilder();
            string className = openApiDocument.Info.Title.Replace(" ", "");
            StringBuilder methods = new StringBuilder();
            foreach (var singlePathItem in openApiDocument.Paths)
            {
                string operationName = singlePathItem.Key.Substring(singlePathItem.Key.LastIndexOf("/") + 1);
                foreach (var singleOperation in singlePathItem.Value.Operations)
                {
                    string methodName = $"{singleOperation.Key}{operationName.Replace("{",string.Empty).Replace("}",string.Empty)}";
                    string methodParameters = string.Empty;
                    string requestUrl = singlePathItem.Key;
                    foreach (var singleParameter in singleOperation.Value.Parameters)
                    {
                        string parameterType = string.Empty;
                        switch (singleParameter.Schema.Type)
                        {
                            case "boolean":
                                parameterType = "bool";
                                break;
                            case "array":
                                parameterType = "object[]";
                                break;
                            case "integer":
                                parameterType = "int";
                                break;
                            default:
                                parameterType = singleParameter.Schema.Type;
                                break;
                        }
                        methodParameters += $"{parameterType} {singleParameter.Name},";
                    }
                    methodParameters += "HttpClient httpClient, CancellationToken cancellationToken = default";
                    string methodSignature = $"public async Task<TOutput> {methodName}<TOutput>({methodParameters})";
                    StringBuilder methodDefinition = new StringBuilder();
                    methodDefinition.AppendLine(methodSignature);
                    methodDefinition.AppendLine("{");
                    methodDefinition.AppendLine("   try");
                    methodDefinition.AppendLine("       {");
                    methodDefinition.AppendLine($"          string requestUrl = $\"{requestUrl.TrimStart('/')}\";");
                    methodDefinition.AppendLine("           var result = await httpClient.GetFromJsonAsync<TOutput>(requestUrl);");
                    methodDefinition.AppendLine("           return result;");
                    methodDefinition.AppendLine("       }");
                    methodDefinition.AppendLine("       catch (Exception ex)");
                    methodDefinition.AppendLine("      {");
                    methodDefinition.AppendLine("throw ex;");
                    methodDefinition.AppendLine("       }");
                    methodDefinition.AppendLine("}");

                    methods.AppendLine(methodDefinition.ToString());
                    methods.AppendLine();
                }
            }
            classDocument.AppendLine("using System;");
            classDocument.AppendLine("using System.Net.Http.Json;");
            classDocument.AppendLine("using System.Net.Http;");
            classDocument.AppendLine("using System.Threading;");
            classDocument.AppendLine("using System.Threading.Tasks;");
            classDocument.AppendLine("namespace PTI.Autogenerated");
            classDocument.AppendLine("{");
            classDocument.AppendLine($"  public class {className}");
            classDocument.AppendLine("  {");
            classDocument.AppendLine($"     {methods.ToString()}");
            classDocument.AppendLine("  }");
            classDocument.AppendLine("}");
            string builtClass = classDocument.ToString();
            context.AddSource($"{className}.cs", builtClass);
        }
    }

    public class OpenApiClientServicesGeneratorSyntaxReceiver : ISyntaxReceiver
    {
        public List<string> RequestedOpenApiDocsUrls { get; set; } = new List<string>();
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is GlobalStatementSyntax)
            {
                var globalStatementSyntax = syntaxNode as GlobalStatementSyntax;
                var identifierStatement = globalStatementSyntax.Statement as LabeledStatementSyntax;
                var identifier = identifierStatement.Identifier.ValueText;
                //var identifierStatementValue= identifierStatement.Statement as value
                var expressionStatementSyntax = identifierStatement.Statement as ExpressionStatementSyntax;
                var literalExpressionSyntax = expressionStatementSyntax.Expression as LiteralExpressionSyntax;
                var token = literalExpressionSyntax.Token.ValueText;
                RequestedOpenApiDocsUrls.Add(token);
                //((Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax)((Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax)identifierStatement.Statement).Expression).Token
            }
        }
    }
}
